module FrequencyDynamicsModels

using ModelingToolkit, OrdinaryDiffEq
using ModelingToolkit: t_nounits as t, D_nounits as D

export get_frequency_metrics, solve_frequency_response, get_nadir_corners_UC2_2024, PWL_UC2_2035_v2
# get_nadir_results_2D, get_nadir_results_3D


@mtkmodel SteamTurbineGovernor begin
    @parameters begin
        Ms = 7.52  # Inertia constant [s]
        Ts = 7     # Turbine time constant [s]
        Fs = 0.3   # Fraction of total power generated by high pressure turbines [p.u.]
        Rs = 0.05  # Droop coeficient [p.u.]
        Ss         # Steam generator rated capacity [MW]
        S          # Sum of rated capacity of all connected generation units [MW]
    end

    @variables begin
        pss(t) # Active power change of steam generator [p.u.]
        Δf(t) # System frequency deviation [p.u.]
    end

    @equations begin
        pss*Rs + D(pss)*Rs*Ts ~ -(Ss/S) * (Δf + D(Δf)*Fs*Ts)
    end
end


@mtkmodel GasCombinedCycleTurbineGovernor begin
    @parameters begin
        Mcc = 13.14 # Inertia constant [s]
        Tcc1 = 0.6  # Time constant 1 [s]
        Tcc2 = 0.5  # Time constant 2 [s]
        Tcc3 = 0.01 # Time constant 3 [s]
        Tcc4 = 0.24 # Time constant 4 [s]
        Rcc = 0.05  # Droop coeficient [p.u.]
        Scc         # Combined cycle generator rated capacity [MW]
        S           # Sum of rated capacity of all connected generation units [MW]
    end

    @variables begin
        u(t)   # output first stage
        pcc(t) # Active power change of combined cycle generator [p.u.]
        Δf(t)  # System frequency deviation [p.u.]
    end

    @equations begin
        Rcc * (u + D(u) * Tcc2) ~ -(Scc/S) * (Δf + D(Δf)*Tcc1)
        u + D(u) * Tcc3 ~ pcc + D(pcc) * Tcc4
    end
end


@mtkmodel HydroStorageTurbineGovernor begin
    @parameters begin
        Mhs = 6.72  # Inertia constant [s]
        Tw = 1      # Water starting time [s]
        Tr = 5      # Reset time for temporary droop [s]
        Rhs = 0.05  # Static droop [p.u.]
        Rt = 0.38   # Temporary droop [p.u.]
        Shs         # Hydro storage generator rated capacity [MW]
        S           # Sum of rated capacity of all connected generation units [MW]
    end

    @variables begin
        phs(t) # Active power change of hydro storage generator [p.u.]
        g(t)   # Gate position [p.u.]
        Δf(t)  # System frequency deviation [p.u.]
    end

    @equations begin
        g*Rhs + D(g)*Rt*Tr ~ -(Δf + D(Δf)*Tr)
        phs + D(phs)*0.5*Tw ~ (Shs/S) * (g - D(g)*Tw)
    end
end


@mtkmodel HydroRunOfRiver begin
    @parameters begin
        Mhr = 5.24   # Inertia constant [s]
        Shr          # Hydro generator rated capacity [MW]
        S            # Sum of rated capacity of all connected generation units [MW]
    end
end


@mtkmodel SynchronousCondenser begin
    @parameters begin
        Msc = 10 # Inertia constant [s]
        Ssc      # Synchronous condenser rated capacity [MW]
        S        # Sum of rated capacity of all connected generation units [MW]
    end
end


@mtkmodel GFLConverterDroop begin
    @parameters begin
        Rgfl = 0.05    # P-f droop gain [p.u.]
        Tgfl = 0.5     # Low pass filter time constant [s]
        Sgfl           # Droop control grid following converter rated capacity [MW]
        S              # Sum of rated capacity of all connected generation units [MW]
    end
    @variables begin
        pgfl(t) # Active power change of converter [p.u.]
        Δf(t)   # System frequency deviation [p.u.]
    end
    @equations begin
        pgfl * Rgfl + D(pgfl) * Tgfl * Rgfl ~ -(Sgfl/S) * (Δf)
    end
end


@mtkmodel GFMConverterDroop begin
    @parameters begin
        Rgfmd = 0.05   # P-f droop gain [p.u.]
        Tgfmd = 0.01   # Low pass filter time constant [s]
        Sgfmd          # Droop control grid forming converter rated capacity [MW]
        S              # Sum of rated capacity of all connected generation units [MW]
    end
    @variables begin
        pgfmd(t) # Active power change of converter [p.u.]
        Δf(t)    # System frequency deviation [p.u.]
    end
    @equations begin
        pgfmd * Rgfmd + D(pgfmd) * Tgfmd * Rgfmd ~ -(Sgfmd/S) * (Δf)
    end
end


@mtkmodel GFMConverterVSM begin
    @parameters begin
        Mgfmv = 1      # Normalized virtual inertia constant of converter [s]
        Dgfmv = 1/0.05 # Damping constant of converter [p.u.]
        Tgfmv = 0.02   # Low pass filter time constant [s]
        Sgfmv          # VSM control grid forming converter rated capacity [MW]
        S              # Sum of rated capacity of all connected generation units [MW]
    end
    @variables begin
        pgfmv(t) # Active power change of converter [p.u.]
        Δf(t) # System frequency deviation [p.u.]
    end
    @equations begin
        pgfmv + D(pgfmv) * Tgfmv ~ -(Sgfmv/S) * (Δf*Dgfmv + D(Δf) * Mgfmv)
    end
end


@mtkmodel PowerSystem begin
    @parameters begin
        Pl    # Power loss due to contigency [MW]
        S     # Sum of rated capacity of all connected generation units [MW]
        K_PF  # Load damping constant for maximum system demand [MW/Hz]
        Ss    # Steam generator rated capacity [MW]
        Scc   # Gas combined cycle generator rated capacity [MW]
        Shs   # Hydro storage generator rated capacity [MW]
        Shr   # Hydro run of river generator rated capacity [MW]
        Ssc   # Synchronous condenser generator rated capacity [MW]
        Sgfl  # Droop control grid following converter rated capacity [MW]
        Sgfmd # Droop control grid forming converter rated capacity [MW]
        Sgfmv # VSM control grid forming converter rated capacity [MW]
    end
    @components begin
        steam_generator = SteamTurbineGovernor(Ss = Ss, S = S)
        combined_cycle_generator = GasCombinedCycleTurbineGovernor(Scc = Scc, S = S)
        hydro_storage_generator = HydroStorageTurbineGovernor(Shs = Shs, S = S)
        hydro_run_of_river_generator = HydroRunOfRiver(Shr = Shr, S = S)
        synchronous_condenser_generator = SynchronousCondenser(Ssc = Ssc, S = S)
        gfl_droop_converter = GFLConverterDroop(Sgfl = Sgfl, S = S)
        gfm_droop_converter = GFMConverterDroop(Sgfmd = Sgfmd, S = S)
        gfm_vsm_converter = GFMConverterVSM(Sgfmv = Sgfmv, S = S) 
    end
    @variables begin
        p(t)       # Total active power change [p.u.]
        Δf(t)      # System frequency deviation [p.u.]
    end
    @equations begin
        Δf * K_PF + D(Δf) * ((steam_generator.Ms*Ss + combined_cycle_generator.Mcc*Scc + hydro_storage_generator.Mhs*Shs + hydro_run_of_river_generator.Mhr*Shr + synchronous_condenser_generator.Msc*Ssc) / S) ~ p
        steam_generator.Δf ~ Δf
        combined_cycle_generator.Δf ~ Δf
        hydro_storage_generator.Δf ~ Δf
        gfl_droop_converter.Δf ~ Δf
        gfm_droop_converter.Δf ~ Δf
        gfm_vsm_converter.Δf ~ Δf
        p ~ steam_generator.pss + combined_cycle_generator.pcc + hydro_storage_generator.phs + gfl_droop_converter.pgfl + gfm_droop_converter.pgfmd + gfm_vsm_converter.pgfmv - Pl    
    end
end



function solve_frequency_response(Pl::Number, S::Number, K_PF::Number, Ss::Number, Scc::Number, Shs::Number, Shr::Number, Ssc::Number, Sgfl::Number, Sgfmd::Number, Sgfmv::Number, simulation_time::Vector{Int64})::ODESolution

    @mtkbuild system = PowerSystem(Pl=Pl, S=S, K_PF=K_PF, Ss=Ss, Scc=Scc, Shs=Shs, Shr=Shr, Ssc=Ssc, Sgfl=Sgfl, Sgfmd=Sgfmd, Sgfmv=Sgfmv)
    initial_conditions = [
        system.Δf => 0.0
        system.steam_generator.pss => 0.0
        system.combined_cycle_generator.pcc => 0.0
        system.combined_cycle_generator.u => 0.0
        system.hydro_storage_generator.g => 0.0
        system.hydro_storage_generator.phs => 0.0
        system.gfl_droop_converter.pgfl => 0.0
        system.gfm_droop_converter.pgfmd => 0.0
        system.gfm_vsm_converter.pgfmv => 0.0
        ]
    problem = ODEProblem(system, initial_conditions, simulation_time)
    solutions = solve(problem, dt=0.01, adaptive=false)
    return solutions

end


function get_frequency_metrics(frequency_metrics_dict::Dict{Int, Tuple{Number, Number, Number}}, time_period:: Int, solutions::ODESolution)::Dict{Int, Tuple{Number, Number, Number}}

    system = solutions.prob.f.sys
    Δf = getproperty(system, :Δf)
    Δnadir = 50 * minimum(solutions[Δf, :])
    RoCof = 50 * (solutions[Δf, 1] - solutions[Δf, findmin(abs.(solutions.t .- 0.1))[2]]) / (solutions.t[1] - solutions.t[findmin(abs.(solutions.t .- 0.1))[2]])
    ΔQSS = 50 * solutions[Δf, end]
    frequency_metrics_dict[time_period] = (Δnadir, RoCof, ΔQSS)
    return frequency_metrics_dict

end

### Heurística de Nadir para 2024

function get_nadir_corners_UC2_2024(Delta_P::Number, Demand::Number, K_PF::Number,
    Ss::StepRange, Scc::StepRange, Shs::StepRange, Shr::Number, Ssc::Number, Sgfld::Number,
    Sgfmd::Number, Sgfmv::Number, simulation_time::Vector{Int})::Dict{String, Union{Nothing, Number}}

    corners = Dict{String, Union{Nothing, Number}}()
    for Ss_value in Ss
        solutions = solve_frequency_response(
            Delta_P / Demand, Demand, K_PF, Ss_value, 0, 0, Shr, Ssc, Sgfld, Sgfmd, Sgfmv, simulation_time
        )
        system = solutions.prob.f.sys
        Δf = getproperty(system, :Δf)
        nadir = 50 * minimum(solutions[Δf, :])
        if nadir >= -1.1
            corners["Ss"] = Ss_value
            break
        end
    end
    
    for Scc_value in Scc
        solutions = solve_frequency_response(
            Delta_P / Demand, Demand, K_PF, 0, Scc_value, 0, Shr, Ssc, Sgfld, Sgfmd, Sgfmv, simulation_time
        )
        system = solutions.prob.f.sys
        Δf = getproperty(system, :Δf)
        nadir = 50 * minimum(solutions[Δf, :])
        if nadir >= -1.1
            corners["Scc"] = Scc_value
            break
        end
    end
    
    for Shs_value in Shs
        solutions = solve_frequency_response(
            Delta_P / Demand, Demand, K_PF, 0, 0, Shs_value, Shr, Ssc, Sgfld, Sgfmd, Sgfmv, simulation_time
        )
        system = solutions.prob.f.sys
        Δf = getproperty(system, :Δf)
        nadir = 50 * minimum(solutions[Δf, :])
        if nadir >= -1.1
            corners["Shs"] = Shs_value
            break
        end
    end
    println("Corners found: ", corners)
    return corners
end


### Heurística de Nadir para 2035

function PWL_UC2_2035_v2(j::Number, Delta_P::Number, Demand::Number, K_PF::Number,
    Scc::Number, Shs_max::Number, Shr::Number, Ssc::Number, Sgfmv::Number, simulation_time::Vector{Int})

    step_value_Shs = 25
    p = Dict{Tuple{Int, String}, Union{Nothing, Number}}()

    for Shs_value in range(0, Shs_max, step=step_value_Shs)
        solutions = solve_frequency_response(
            Delta_P / Demand, Demand, K_PF, 0, Scc, Shs_value, 
            Shr, Ssc, 0, 0, Sgfmv, simulation_time)
        system = solutions.prob.f.sys
        Δf = getproperty(system, :Δf)
        nadir = 50 * minimum(solutions[Δf, :])
        if nadir >= -1.1
            p[(0,"Shs")] = Shs_value
            break
        end
    end

    m = Dict{Tuple{Int, String}, Union{Nothing, Number}}()
    b = Dict{Int, Union{Nothing, Number}}()
    
    nadir_constraints = Dict()
    nadir_constraints["p"] = p
    nadir_constraints["m"] = m
    nadir_constraints["b"] = b

    return nadir_constraints

end



### Funciones auxiliares para generar gráficos

# function get_nadir_results_2D(Delta_P::Number, Demand::Number, K_PF::Number, Ss::Number, Scc::Number, Shs::Number, Shr::Number, Ssc::StepRange, Sgfld::Number, Sgfmd::Number, Sgfmv::StepRange, simulation_time::Vector{Int})::Dict{Tuple{Number, Number}, Number}

#     nadir_values = Dict{Tuple{Number, Number}, Number}()

#     for Ssc_value in Ssc
#         for Sgfmv_value in Sgfmv
#             solutions = solve_frequency_response(Delta_P/Demand, Demand, K_PF, Ss, Scc, Shs, Shr, Ssc_value, Sgfld, Sgfmd, Sgfmv_value, simulation_time)
#             system = solutions.prob.f.sys
#             Δf = getproperty(system, :Δf)
#             nadir_values[(Ssc_value, Sgfmv_value)] = 50 * minimum(solutions[Δf, :])
#         end
#     end
              
#     return nadir_values
                
# end


# function get_nadir_results_3D(Delta_P::Number, Demand::Number, K_PF::Number, Ss::StepRange, Scc::StepRange, Shs::StepRange, Shr::Number, Ssc::Number, Sgfld::Number, Sgfmd::Number, Sgfmv::Number, simulation_time::Vector{Int})::Dict{Tuple{Number, Number, Number}, Number}

#     nadir_values = Dict{Tuple{Number, Number, Number}, Number}()
#     for Ss_value in Ss
#         println("Ss: ", Ss_value)
#         for Scc_value in Scc
#             for Shs_value in Shs
#                 solutions = solve_frequency_response(Delta_P/Demand, Demand, K_PF, Ss_value, Scc_value, Shs_value, Shr, Ssc, Sgfld, Sgfmd, Sgfmv, simulation_time)
#                 system = solutions.prob.f.sys
#                 Δf = getproperty(system, :Δf)
#                 nadir_values[(Ss_value, Scc_value, Shs_value)] = 50 * minimum(solutions[Δf, :])
#             end
#         end
#     end           
#     return nadir_values 

# end

end